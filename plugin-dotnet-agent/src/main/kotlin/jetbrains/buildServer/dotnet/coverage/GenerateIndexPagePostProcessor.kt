package jetbrains.buildServer.dotnet.coverage

import com.intellij.openapi.diagnostic.Logger
import jetbrains.buildServer.agent.BuildProgressLogger
import jetbrains.buildServer.dotnet.coverage.serviceMessage.DotnetCoverageParameters
import jetbrains.buildServer.dotnet.CoverageConstants
import jetbrains.buildServer.util.FileUtil
import jetbrains.buildServer.util.StringUtil
import java.io.BufferedWriter
import java.io.File
import java.io.FileWriter
import java.io.IOException
import java.io.Writer
import java.util.Collections
import java.util.Queue
import java.util.LinkedList
import kotlin.Comparator
import kotlin.collections.ArrayList
import kotlin.collections.HashSet

class GenerateIndexPagePostProcessor : ReportFilesProcessor {

    @Throws(IOException::class)
    private fun generateIndexPage(home: File,
                                  preferredReportName: String?,
                                  logger: BuildProgressLogger) {

        val index = File(home, "index.html")

        if (preferredReportName != null && !StringUtil.isEmptyOrSpaces(preferredReportName)) {
            val preferredIndex = File(home, preferredReportName)
            if (preferredIndex.isFile) {
                if (index.isFile) {
                    logger.warning(
                        "Report folder contains both preferred index file " + preferredReportName + " and index.html. " +
                                "Existing index.html file will be replaced with " + preferredReportName)
                }

                FileUtil.copy(preferredIndex, index)
                return
            }
        }

        if (index.isFile) return

        val generatedFiles = listGeneratedFiles(home)
        if (generatedFiles.size == 1) {
            val oneFile = generatedFiles[0]
            FileUtil.copy(oneFile, index)
            if (index.isFile) return
        }

        val filesMap: MutableList<String> = ArrayList(generatedFiles.size)
        for (file: File in generatedFiles) {
            FileUtil.getRelativePath(home, file)?.let {
                filesMap.add(it)
            }
        }
        Collections.sort(filesMap, PATH_COMPARATOR)

        val writer: Writer = BufferedWriter(FileWriter(index))
        writer.write("<!DOCTYPE html>")
        writer.write("<html><head>")
        generateStyle(writer)
        writer.write("<title>Generated files list</title><body>")
        writer.write("<div>This is an autogenerated index file (there was no index.html found in the generated report).</div>")
        writer.write("<ul>")
        for (generatedFile: String in filesMap) {
            writer.write("<li><a href='$generatedFile'>$generatedFile</a></li>")
        }
        writer.write("</ul></html>")
        writer.close()
    }

    @Throws(IOException::class)
    private fun generateStyle(writer: Writer) {
        writer.write("<style type=\"text/css\">\n" +
                " ul { padding:0.5em 0 0 2em; margin:0; white-space:nowrap;}\n" +
                "  a:hover {\n" +
                "    color:#1564C2;\n" +
                "    text-decoration:underline;\n" +
                "}\n" +
                "  a {\n" +
                "    color:#1564C2;\n" +
                "    text-decoration:none;\n" +
                "}\n" +
                "ul li {\n" +
                "   list-style-image:none;\n" +
                "   list-style-position:outside;\n" +
                "   list-style-type:none;\n" +
                "}\n" +
                "div div {\n" +
                "  color:#888;\n" +
                "  font-size:80%;\n" +
                "}\n" +
                "p { font-size:1.2em; }\n" +
                "body {\n" +
                "  color:var(--ring-text-color, #1f2326);\n" +
                "  font-family:helvetica neue, arial, sans-serif;\n" +
                "  font-size:82%;\n" +
                "  line-height:1.5em;\n" +
                "}\n" +
                "</style>")
    }

    override fun processFiles(build: DotnetCoverageParameters,
                              result: DotnetCoverageGenerationResult) {

        val report: File? = result.htmlReport
        if (report != null && report.isDirectory) {
            try {
                generateIndexPage(
                    report,
                    build.getRunnerParameter(CoverageConstants.COVERAGE_HTML_REPORT_INDEX_KEY),
                    build.getBuildLogger())
            } catch (e: IOException) {
                val message = "Failed to generate report index. " + e.message
                build.getBuildLogger().warning(message)
                LOG.warn(message, e)
            }
        }
    }

    private fun listGeneratedFiles(home: File): List<File> {
        val visited = HashSet<File>()
        val html: MutableList<File> = ArrayList()
        val tasks: Queue<File> = LinkedList()
        tasks.add(home)

        var dir: File? = home
        while (dir != null) {
            if (visited.contains(dir)) {
                dir = tasks.poll()
                continue
            }
            visited.add(dir)

            val children = dir.listFiles()
            if (children == null) {
                dir = tasks.poll()
                continue
            }
            for (child in children) {
                if (child.isDirectory) {
                    tasks.add(child)
                } else if (child.name.endsWith(".html")) {
                    html.add(child)
                }
            }
            dir = tasks.poll()
        }
        return html
    }

    companion object {
        private val LOG = Logger.getInstance(GenerateIndexPagePostProcessor::class.java.name)

        private val PATH_COMPARATOR: Comparator<String> = object : Comparator<String> {
            private fun slashes(s: String): Int {
                var cnt = 0
                for (i in 0 until s.length) {
                    val c = s[i]
                    if (c == '/' || c == '\\') cnt++
                }
                return cnt
            }

            override fun compare(o1: String, o2: String): Int {
                val s = slashes(o1) - slashes(o2)
                return if (s != 0) s else o1.compareTo(o2)
            }
        }
    }
}
